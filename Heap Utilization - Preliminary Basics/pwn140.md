# 挑战简介
多线程支持

# 思路
主线程和分线程的执行流程就是本节的内容  
1. 初始化和栈保护
```
v8 = __readfsqword(0x28u);  // 读取栈金丝雀值，用于栈溢出保护
init(*(_QWORD *)&argc, argv, envp);  // 初始化函数
logo();                     // 显示程序logo
```
2. 主线程内存操作演示
```
v3 = getpid();
printf("Welcome to per thread arena example::%d\n", v3);

puts("Before malloc in main thread");
getchar();                  // 等待用户输入，便于观察
ptr = malloc(0x3E8uLL);    // 分配1000字节内存
puts("After malloc and before free in main thread");
getchar();                  // 再次等待
free(ptr);                 // 释放内存
puts("After free in main thread");
getchar();                  // 最后一次等待
```
3. 线程创建和管理
```
if ( pthread_create(&newthread, 0LL, threadFunc, 0LL) )
{
    puts("Thread creation error");
    result = -1;
}
```
4. 线程同步
```
else if ( pthread_join(newthread, &thread_return) )
{
    puts("Thread join error");
    result = -1;
}
```

主线程创建了子线程后，同步操作后，主线程会等待子线程结束，然后返回主线程继续执行原内容  
